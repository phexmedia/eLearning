<!DOCTYPE html>
<html>
	<head>
		<script src="jquery-1.9.1.min.js"></script>
		<script src="jquery-ui-1.10.3/js/jquery-ui-1.10.3.custom.min.js"></script>
		<link  rel="stylesheet" type="text/css" href="jquery-ui-1.10.3/css/ui-darkness/jquery-ui-1.10.3.custom.min.css">

	</head>
	<body>

		<canvas id="canvas" width="600" height="400">
			No Html 5 support.
		</canvas>
		<!--<input type="text" name="t" value="0.2" id="t" />-->
		<p>max. Rekursionstiefe: <span id ="maxDepth">1</span></p>
		<div id = "depthSlider" style="width:300px"></div>
		<p>Teilungsverh&auml;ltnis: <span id ="t">0.2:0.8</span></p>
		<div id = "tSlider" style="width:300px"></div>
		<input type="button" name="reset" value="reset" id="reset"/>
		<br/>

		show Iterations:
		<input type="checkbox" name="showCasteljauIterations" id="showCasteljauIterations"/>
		<br/>
		show curve:
		<input type="checkbox" name="showCasteljauCurve" id="showCasteljauCurve"/>
		<br/>
		show lines:
		<input type="checkbox" name="showCasteljauLine" id="showCasteljauLine"/>
		<br/>
		showCasteljau Point:
		<input type="checkbox" name="showCasteljauPoint" id="showCasteljauPoint"/>

		<script type="text/javascript">
			// Teilunsverhältnis der Strecken. Modifizierbar durch JSlider

			var t = 0.2;
			// COLORS
			var inactivePointColor = "#aaaaaa";
			var inactiveLineColor = "#999999";
			var activePointColor = "#aa00aa";
			var activeLineColor = "#aa0000";

			// Farbe für den Punkt der die Strecken einteilt
			var tPointColor = "#dd0000";
			var casteljauPointColor = "#0000dd";

			var backgroundColor = "#eeeeee";
			
			var showCasteljauCurve = false;
			var showCasteljauIterations = false;
			var showCasteljauLine = false;
			var showCasteljauPoint = false;

			var pointSize = 10;

			var width = 600;
			var height = 400;

			var canvas;
			var c;
			//Konstruktor Array([]) erzeugt array der länge 1, war das gewollt?
			var ctrlPoints = new Array();
			var curvePoints = new Array();
			// Hier rein kommen die einzelnen Punkte der rekursionen des decasteljau rein
			var cycles = new Array(new Array());
			var maxDepth = 1;
			
			var tSlider;
			var depthSlider;


			$(document).ready(function() {
				canvas = document.getElementById("canvas");
				c = canvas.getContext("2d");
				jCanvas = $(canvas);
				jCanvas.css({
					"width" : width,
					"height" : height
				});

				//MOUSEHANDLERS
				jCanvas.click(function(e) {
					var clickPos = getMousePos(canvas, e);
					// console.log(clickPos);
					ctrlPoints.push(clickPos);
					// NACH DEM ZWEITEN KLICK SIND HIER ALLE GLEICH... WTF
					//for (var i=0; i < ctrlPoints.length; i++) {
					//	console.log(ctrlPoints[i].x+" , "+ctrlPoints[i].y);
					//};
					// console.log( ctrlPoints[ctrlPoints.length-1]);
					// CLICKPOS[0] ÄNDERT SICH NACH MEHREREN KLICKS... WTF
					update();
					updateSlider();

					//console.log('controlPoints: '+ctrlPoints.length);
					//console.log('curvePoints: '+curvePoints.length);
				})
				
				depthSlider = $('#depthSlider').slider({
					animate : 'fast',
					value : maxDepth,
					step: 1,
					min : 0,
					max : maxDepth,
					slide : function(e, ui) {
						maxDepth = ui.value;
						$('#maxDepth').text(maxDepth);
						update();
					}
				});

				tSlider = $('#tSlider').slider({
					animate : 'fast',
					value : t * 100,
					min : 0,
					max : 100,
					slide : function(e, ui) {
						t = ui.value / 100;
						$('#t').text(t +':'+ (1-t));
						update();
					}
				});
				
				$('#showCasteljauCurve').change(function(e){
					showCasteljauCurve = this.checked;
					update();
				}).attr("checked", showCasteljauCurve);
				
				$('#showCasteljauIterations').change(function(e){
					showCasteljauIterations = this.checked;
					console.log(showCasteljauIterations);
					update();
				}).attr("checked", showCasteljauIterations);
				
				$('#showCasteljauLine').change(function(e){
					showCasteljauLine = this.checked;
					update();
				}).attr("checked", showCasteljauLine);
				
				$('#showCasteljauPoint').change(function(e){
					showCasteljauPoint = this.checked;
					update();
				}).attr("checked", showCasteljauPoint);

				$('#reset').click(function(e) {
					reset();
				});

				// INIT STAGE
				update();
			})
			
			function update() {

				evalCasteljau();
				drawCasteljau();
			}
			
			function updateSlider(){
				depthSlider.slider("option","max", cycles.length-1);
			}

			function drawCasteljau() {
				canvas.width = canvas.width;
				c.clearRect(0, 0, width, height);
				c.fillStyle = backgroundColor;
				c.fillRect(0, 0, width, height);
				
				if (curvePoints.length > 0 && showCasteljauCurve) {
					c.moveTo(curvePoints[0].x, curvePoints[0].y);
					for (var i = 1; i < curvePoints.length; i++) {
						c.strokeStyle = activeLineColor;
						c.lineTo(curvePoints[i].x, curvePoints[i].y);
						c.stroke();
					}
				}

				for (var i = 0; i < ctrlPoints.length; i++) {
					c.moveTo(ctrlPoints[i].x, ctrlPoints[i].y);
					if (i < ctrlPoints.length - 1) {
						if (showCasteljauLine) {
							// DRAW lines between ctrlpoints
							c.lineTo(ctrlPoints[i + 1].x, ctrlPoints[i + 1].y);
							c.strokeStyle = inactiveLineColor;
							c.stroke();
							
						}
					}
					//DRAW CONTROLPOINTS
					c.fillStyle = activePointColor;
					c.fillRect(ctrlPoints[i].x - pointSize / 2, ctrlPoints[i].y - pointSize / 2, pointSize, pointSize);
					
					//DRAW CASTELJAUPOINT FOR GIVEN T FROM SLIDER
					//NIEMALS VERSCHIEBEN, LÖSCHEN ODER SO! Das hier befüllt cycles mit dem aktuellen wert. sollte einmal nach evalCasteljau kommen!
					var point = getCasteljauPoint(1-t);
					if (showCasteljauPoint && ctrlPoints.length >= 3) {
						c.fillStyle = casteljauPointColor;
						c.fillRect(point.x - pointSize / 2, point.y - pointSize / 2, pointSize, pointSize);

					}
					
					//DRAW HELPLINES
					if (maxDepth > cycles.length) maxDepth = cycles.length;
					if(showCasteljauIterations){
						for(var j = 1; j<=maxDepth;j++ ){
							var cycle = cycles[j] ? cycles[j] : undefined;
							if(cycle){
								for(var k = 0; k < cycles[j].length;k++){
								// DRAW point that splits this range
									var point = cycles[j][k];
									if(point){
								
										c.fillStyle = tPointColor;
										c.fillRect(point.x - pointSize / 2 ,point.y - pointSize / 2, pointSize, pointSize);
					
										// DRAW LINES between splitPoints
										if (i < cycles[j].length - 1) {
											var nextPoint = cycles[j][k+1];
											if(nextPoint){
												c.moveTo(point.x,point.y);
												c.lineTo(nextPoint.x,nextPoint.y);
											}
										}
									}
								}
							}
					
						}
					
					}

				}
			}
			
			function drawRecursions(maxDepth){
				for (var k = 1; k <= n; k++) {
					for (var i = 0; i <= n - k; i++) {
						tempPoints[i].x = t * tempPoints[i].x + (1 - t) * tempPoints[i + 1].x;
						tempPoints[i].y = t * tempPoints[i].y + (1 - t) * tempPoints[i + 1].y;
					}
				}
			}

			function evalCasteljau() {
				curvePoints = [];
				if (ctrlPoints.length >= 3) {
					for (var i = 0.0; i <= 1.05; i += 0.05) {
						curvePoints.push
						curvePoints.push(getCasteljauPoint(i));
					}
				}
			}

			function getCasteljauPoint(t) {
				cycles = new Array(new Array())
				var tempPoints = [];
				var n = ctrlPoints.length - 1;

				for (var i = 0; i <= n; i++) {
					tempPoints.push({
						x : ctrlPoints[i].x,
						y : ctrlPoints[i].y
					});
				}
				// console.log(ctrlPoints);

				for (var k = 1; k <= n; k++) {
					var tmp = new Array();
					for (var i = 0; i <= n - k; i++) {
						tempPoints[i].x = t * tempPoints[i].x + (1 - t) * tempPoints[i + 1].x;
						tempPoints[i].y = t * tempPoints[i].y + (1 - t) * tempPoints[i + 1].y;
						tmp.push({x:tempPoints[i].x,y:tempPoints[i].y})
					}
						cycles.push(tmp);
				}
				// HIER STEHT ÜBERALL DAS GLEICHE DRIN. WARUM DIE FOR SCHLEIFE WENN WIR EH NUR [0] ZURUECKGEBEN?

				return tempPoints[0];
				//console.log(tempPoints);

			}

			function getMousePos(canvas, evt) {
				var rect = canvas.getBoundingClientRect();
				// console.log(evt);
				//console.log((evt.clientX - rect.left)+" "+(evt.clientY - rect.top)	);
				return {
					x : evt.clientX - rect.left,
					y : evt.clientY - rect.top
				};

			}

			function reset() {
				console.log('reset');
				canvas.width = canvas.width;
				ctrlPoints = [];
				curvePoints = [];
				update();
			}

		</script>
	</body>
</html>