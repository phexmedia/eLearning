<!DOCTYPE html>
<html>
	<head>
		<meta charset='utf-8'>
		<script src="jquery-1.9.1.min.js"></script>
		<script src="jquery-ui-1.10.3/js/jquery-ui-1.10.3.custom.min.js"></script>
		<link  rel="stylesheet" type="text/css" href="jquery-ui-1.10.3/css/ui-darkness/jquery-ui-1.10.3.custom.min.css">

	</head>
	<body>

		<canvas id="canvas" width="600" height="400">
			No Html 5 support.
		</canvas>
		<!--<input type="text" name="t" value="0.2" id="t" />-->
		<p>
			max. Rekursionstiefe:
		</p>
		<div id = "depthSlider" style="width:300px"></div>
		<p>
			Teilungsverhältnis:
		</p>
		<div id = "tSlider" style="width:300px"></div>
		<input type="button" name="reset" value="reset" id="reset"/>
		<br/>

		show curve:
		<input type="checkbox" name="showCasteljauCurve" id="showCasteljauCurve"/>
		<br/>
		show lines:
		<input type="checkbox" name="showCasteljauLine" id="showCasteljauLine"/>
		<br/>
		showCasteljau Point:
		<input type="checkbox" name="showCasteljauPoint" id="showCasteljauPoint"/>

		<script type="text/javascript">
			// Teilunsverhältnis der Strecken. Modifizierbar durch JSlider

			var t = 0.2;
			// COLORS
			var inactivePointColor = "#aaaaaa";
			var inactiveLineColor = "#999999";
			var activePointColor = "#aa00aa";
			var activeLineColor = "#aa0000";

			// Farbe für den Punkt der die Strecken einteilt
			var tPointColor = "#dd0000";
			var casteljauPointColor = "#0000dd";

			var backgroundColor = "#eeeeee";

			var showCasteljauCurve = true;
			var showCastelJauIterations = false;
			var showCasteljauLine = true;
			var showTPoint = true;
			var showCasteljauPoint = true;

			var pointSize = 10;

			var width = 600;
			var height = 400;

			var canvas;
			var c;
			//Konstruktor Array([]) erzeugt array der länge 1, war das gewollt?
			var ctrlPoints = new Array();
			var curvePoints = new Array();
			// Hier rein kommen die einzelnen Punkte der rekursionen des decasteljau rein
			var cycles = new Array(new Array());
			var maxDepth = 1;

			var tSlider;
			var depthSlider;

			var ctrlPointClicked;
			var dragMode;
			var ctrlPointToDrag;

			$(document).ready(function() {
				canvas = document.getElementById("canvas");
				c = canvas.getContext("2d");
				jCanvas = $(canvas);
				jCanvas.css({
					"width" : width,
					"height" : height
				});

				//MOUSEHANDLERS
				jCanvas.click(function(e) {
					var clickPos = getMousePos(canvas, e);
					// TODO
					if (!dragMode) {
						ctrlPointClicked = false;
						for (var i = 0; i < ctrlPoints.length; i++) {
							if (Math.abs(ctrlPoints[i].x - clickPos.x) < pointSize / 2 && Math.abs(ctrlPoints[i].y - clickPos.y) < pointSize / 2) {
								ctrlPointClicked = true;
								dragMode = true;
								ctrlPointToDrag = i; 
								break;
							} else {
								ctrlPointClicked = false;
							}
						}
						//console.log(ctrlPoints.length)
					} else {
						dragMode = false;
						ctrlPoints[ctrlPointToDrag].x = clickPos.x;
						ctrlPoints[ctrlPointToDrag].y = clickPos.y;
						update();
						updateSlider();
					}

					if (!ctrlPointClicked) {
						ctrlPoints.push(clickPos);
						update();
						updateSlider();
					}
					//console.log('controlPoints: '+ctrlPoints.length);
					//console.log('curvePoints: '+curvePoints.length);
				})
				depthSlider = $('#depthSlider').slider({
					animate : 'fast',
					value : maxDepth,
					step : 1,
					min : 0,
					max : maxDepth,
					slide : function(e, ui) {
						maxDepth = ui.value;
						update();
					}
				});

				tSlider = $('#tSlider').slider({
					animate : 'fast',
					value : t * 100,
					min : 0,
					max : 100,
					slide : function(e, ui) {
						t = ui.value / 100;
						update();
					}
				});

				$('#showCasteljauCurve').change(function(e) {
					showCasteljauCurve = this.value;
					update();
				}).attr("checked", showCasteljauCurve);

				$('#showCasteljauLine').change(function(e) {
					showCasteljauLine = this.value;
					update();
				}).attr("checked", showCasteljauLine);

				$('#showCasteljauPoint').change(function(e) {
					showCasteljauPoint = this.value;
					update();
				}).attr("checked", showCasteljauPoint);

				$('#reset').click(function(e) {
					reset();
				});

				$('#t').blur(function(e) {
					console.log("t set to " + this.value);
					t = this.value;
					update();
				})
				// INIT STAGE
				update();
			})
			function update() {

				evalCasteljau();
				drawCasteljau();
			}

			function updateSlider() {
				depthSlider.slider("option", "max", cycles.length - 1);
			}

			function drawCasteljau() {
				canvas.width = canvas.width;
				c.clearRect(0, 0, width, height);
				c.fillStyle = backgroundColor;
				c.fillRect(0, 0, width, height);
				if (curvePoints.length > 0 && showCasteljauCurve) {
					c.moveTo(curvePoints[0].x, curvePoints[0].y);
					for (var i = 1; i < curvePoints.length; i++) {
						c.strokeStyle = activeLineColor;
						c.lineTo(curvePoints[i].x, curvePoints[i].y);
						c.stroke();
					}
				}

				for (var i = 0; i < ctrlPoints.length; i++) {
					c.moveTo(ctrlPoints[i].x, ctrlPoints[i].y);
					if (i < ctrlPoints.length - 1) {
						if (showCasteljauLine) {
							// DRAW lines between ctrlpoints
							c.lineTo(ctrlPoints[i + 1].x, ctrlPoints[i + 1].y);
							c.strokeStyle = inactiveLineColor;
							c.stroke();

						}
					}
					//DRAW CONTROLPOINTS
					c.fillStyle = activePointColor;
					c.fillRect(ctrlPoints[i].x - pointSize / 2, ctrlPoints[i].y - pointSize / 2, pointSize, pointSize);

					//DRAW CASTELJAUPOINT FOR GIVEN T FROM SLIDER
					if (showCasteljauPoint && ctrlPoints.length >= 3) {
						c.fillStyle = casteljauPointColor;
						point = getCasteljauPoint(1 - t);
						c.fillRect(point.x - pointSize / 2, point.y - pointSize / 2, pointSize, pointSize);

					}

					//DRAW HELPLINES
					if (maxDepth > cycles.length)
						maxDepth = cycles.length;

					for (var j = 1; j <= maxDepth; j++) {
						var cycle = cycles[j] ? cycles[j] : undefined;
						if (cycle) {
							for (var k = 0; k < cycles[j].length; k++) {
								// DRAW point that splits this range
								var point = cycles[j][k];
								if (point) {

									c.fillStyle = tPointColor;
									c.fillRect(point.x - pointSize / 2, point.y - pointSize / 2, pointSize, pointSize);

									// DRAW LINES between splitPoints
									if (i < cycles[j].length - 1) {
										var nextPoint = cycles[j][k + 1];
										if (nextPoint) {
											c.moveTo(point.x, point.y);
											c.lineTo(nextPoint.x, nextPoint.y);
										}
									}
								}

							}

						}

					}

				}
			}

			function drawRecursions(maxDepth) {
				for (var k = 1; k <= n; k++) {
					for (var i = 0; i <= n - k; i++) {
						tempPoints[i].x = t * tempPoints[i].x + (1 - t) * tempPoints[i + 1].x;
						tempPoints[i].y = t * tempPoints[i].y + (1 - t) * tempPoints[i + 1].y;
					}
				}
			}

			function evalCasteljau() {
				curvePoints = [];
				if (ctrlPoints.length >= 3) {
					for (var i = 0.0; i <= 1.05; i += 0.05) {
						curvePoints.push
						curvePoints.push(getCasteljauPoint(i));
					}
				}
			}

			function getCasteljauPoint(t) {
				cycles = new Array(new Array())
				var tempPoints = [];
				var n = ctrlPoints.length - 1;

				for (var i = 0; i <= n; i++) {
					tempPoints.push({
						x : ctrlPoints[i].x,
						y : ctrlPoints[i].y
					});
				}
				// console.log(ctrlPoints);

				for (var k = 1; k <= n; k++) {
					var tmp = new Array();
					for (var i = 0; i <= n - k; i++) {
						tempPoints[i].x = t * tempPoints[i].x + (1 - t) * tempPoints[i + 1].x;
						tempPoints[i].y = t * tempPoints[i].y + (1 - t) * tempPoints[i + 1].y;
						tmp.push({
							x : tempPoints[i].x,
							y : tempPoints[i].y
						})
					}
					cycles.push(tmp);
				}
				// HIER STEHT ÜBERALL DAS GLEICHE DRIN. WARUM DIE FOR SCHLEIFE WENN WIR EH NUR [0] ZURUECKGEBEN?

				return tempPoints[0];
				//console.log(tempPoints);

			}

			function getMousePos(canvas, evt) {
				var rect = canvas.getBoundingClientRect();
				// console.log(evt);
				//console.log((evt.clientX - rect.left)+" "+(evt.clientY - rect.top)	);
				return {
					x : evt.clientX - rect.left,
					y : evt.clientY - rect.top
				};

			}

			function reset() {
				console.log('reset');
				canvas.width = canvas.width;
				ctrlPoints = [];
				curvePoints = [];
				update();
			}

		</script>
	</body>
</html>